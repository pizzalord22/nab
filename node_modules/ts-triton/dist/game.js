"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TritonGame = void 0;
class TritonGame {
    constructor(client, gameId) {
        this.client = client;
        this.id = gameId;
    }
    /**
     * Generic function used to send orders to the game.
     *
     * @param type The type of order.
     * @param order The order data.
     */
    order(type, order) {
        return this.client.gameRequest(type, this.id, {
            order
        });
    }
    /**
     * Updates and returns the current state of the game universe.
     * @see currentUniverse
     */
    async getFullUniverse() {
        this.currentUniverse = await this.order('order', 'full_universe_report');
        return this.currentUniverse;
    }
    /**
     * Returns intel data from the game.
     */
    getIntel() {
        return this.client.gameRequest('intel_data', this.id);
    }
    /**
     * Returns the amount of unread messages.
     */
    getUnreadCount() {
        return this.client.gameRequest('fetch_unread_count', this.id);
    }
    /**
     * Returns the player's achievements.
     */
    getPlayerAchievements() {
        return this.client.gameRequest('fetch_player_achievements', this.id);
    }
    /**
     * Generic function used to get messages sent to the player.
     *
     * @param messageType The type of message, either game_diplomacy or game_event.
     * @param count The amount of messages to retrieve.
     * @param offset The offset to retrieve from.
     */
    getMessages(messageType, count, offset = 0) {
        const options = {
            count,
            offset,
            group: messageType
        };
        return this.client.gameRequest('fetch_game_messages', this.id, options);
    }
    /**
     * Get the messages sent to the user by other players.
     *
     * @param count The amount of messages to retrieve.
     * @param offset The offset to retrieve from.
     */
    getDiplomacyMessages(count, offset = 0) {
        return this.getMessages('game_diplomacy', count, offset);
    }
    /**
     * Get the game event messages.
     *
     * @param count The amount of messages to retrieve.
     * @param offset The offset to retrieve from.
     */
    getEventMessages(count, offset = 0) {
        return this.getMessages('game_event', count, offset);
    }
    /**
     * Marks a message as read.
     *
     * @param messageKey The message_key of the message.
     */
    readMessage(messageKey) {
        return this.client.gameRequest('read_game_message', this.id, {
            message_key: messageKey
        });
    }
    /**
     * Buy economy on a star.
     *
     * @param star The ID of the star to buy on.
     * @param price The price of the economy upgrade.
     */
    buyEconomy(star, price) {
        return this.order('batched_orders', `upgrade_economy,${star},${price}`);
    }
    /**
     * Buy industry on a star.
     *
     * @param star the ID of the star to buy on.
     * @param price The price of the industry upgrade.
     */
    buyIndustry(star, price) {
        return this.order('batched_orders', `upgrade_industry,${star},${price}`);
    }
    /**
     * Buy science on a star.
     *
     * @param star The ID of the star to buy on.
     * @param price The price of the industry upgrade.
     */
    buyScience(star, price) {
        return this.order('batched_orders', `upgrade_science,${star},${price}`);
    }
    /**
     * Sets the path and actions of a fleet.
     * The orders are set, not added.
     *
     * @param shipId The ID of the fleet to order.
     * @param orders An array of {@link ShipOrder} to be encoded and sent to the fleet.
     */
    giveShipOrder(shipId, orders) {
        return this.order('order', `add_fleet_orders,${shipId},${this.encodeShipOrders(orders)},0`);
    }
    /**
     * Used to encode an array of {@link ShipOrder} into the right format string that the game is expecting.
     * All the values of the same type go at the same time, rather than the values of each star.
     * The format is ship_delays,target_planets,action_types,ship_amount.
     *
     * @param orders The array of orders.
     */
    encodeShipOrders(orders) {
        let encoded = '';
        // Encode the delays
        encoded = orders.reduce((previous, current) => {
            return previous + current.delay + '_';
        }, '').slice(0, -1) + ',';
        // Encode the target planets
        encoded = encoded + orders.reduce((previous, current) => {
            return previous + current.targetPlanetId + '_';
        }, '').slice(0, -1) + ',';
        // Encode the actions
        encoded = encoded + orders.reduce((previous, current) => {
            return previous + this.encodeAction(current.action) + '_';
        }, '').slice(0, -1) + ',';
        // Encode the ship amounts
        encoded = encoded + orders.reduce((previous, current) => {
            return previous + current.ships + '_';
        }, '').slice(0, -1);
        return encoded;
    }
    /**
     * Get the stars in travel distance of the given star.
     * The hyperspace research level of the user is used for all calculations, not the level of the given star's owner.
     *
     * @param starId The ID of the star to calculate for.
     */
    getStarsInDistance(starId) {
        /**
         * The light years a player can travel is (hyperspace_level + 3).
         * When using game coordinates, the light years have to be divided by 8 to be in proper scale.
         */
        const hyperspaceLevel = this.currentUniverse.players[this.currentUniverse.player_uid].tech.propulsion.level;
        const lightYears = hyperspaceLevel + 3;
        const translatedDistance = lightYears / 8;
        const originStar = this.currentUniverse.stars[starId];
        return Object.values(this.currentUniverse.stars).filter(star => {
            return (star.uid !== originStar.uid) &&
                (this.getDistanceBetweenStars(originStar.uid, star.uid) <= translatedDistance);
        });
    }
    /**
     * Encode the action strings into the number the game is expecting.
     *
     * @param action The action string to encode.
     */
    encodeAction(action) {
        switch (action) {
            case 'Do Nothing': return 0;
            case 'Collect All': return 1;
            case 'Drop All': return 2;
            case 'Collect': return 3;
            case 'Drop': return 4;
            case 'Collect All But': return 5;
            case 'Drop All But': return 6;
            case 'Garrison Star': return 7;
        }
    }
    /**
     * Calculate the distance between stars using the distance formula.
     * The returned distance is in coordinate scale, not light year scale.
     * Multiply by 8 to get the amount of light years.
     *
     * @param startStarId The ID of the star to calculate from.
     * @param endStarId The ID of the star to calculate to.
     */
    getDistanceBetweenStars(startStarId, endStarId) {
        const startStar = this.currentUniverse.stars[startStarId];
        const endStar = this.currentUniverse.stars[endStarId];
        return Math.sqrt(Math.pow(parseFloat(endStar.x) - parseFloat(startStar.x), 2) +
            Math.pow(parseFloat(endStar.y) - parseFloat(startStar.y), 2));
    }
    /**
     * Find a path between two stars.
     * Uses an implementation of the A* algorithm to find the path.
     * Returns the list of stars, in order from start to end, to travel to in order to reach the end.
     *
     * @param startStarId The ID of the star to start from.
     * @param endStarId The ID of the star to end in.
     * @param allowedToCrossOtherPlayers If the algorithm is allowed to consider stars owned by other players.
     * @param otherPlayerWeightMultiplied Weight to multiple the distance of stars owned by other players if allowed.
     */
    findPathToStar(startStarId, endStarId, allowedToCrossOtherPlayers = false, otherPlayerWeightMultiplied = 2) {
        const stars = this.currentUniverse.stars;
        const endStar = stars[endStarId];
        const openList = [{
                star: stars[startStarId],
                f: 0,
                g: 0,
                h: 0,
                visited: false,
                closed: false,
                parent: null
            }];
        while (openList.length > 0) {
            let lowInd = 0;
            for (let i = 0; i < openList.length; i++) {
                if (openList[i].f < openList[lowInd].f) {
                    lowInd = i;
                }
            }
            const currentNode = openList[lowInd];
            if (currentNode.star.uid === endStarId) {
                let curr = currentNode;
                const finalPath = [];
                while (curr.parent) {
                    finalPath.push(curr);
                    curr = curr.parent;
                }
                return finalPath.reverse().map(r => r.star);
            }
            openList.splice(lowInd, 1);
            currentNode.closed = true;
            const neighbors = this.getStarsInDistance(currentNode.star.uid).map(star => {
                return {
                    star,
                    f: 0,
                    g: 0,
                    h: 0,
                    visited: false,
                    closed: false,
                    parent: null
                };
            });
            for (let i = 0; i < neighbors.length; i++) {
                const neighbor = neighbors[i];
                if (neighbor.closed) {
                    continue;
                }
                const otherPlayer = neighbor.star.puid !== this.currentUniverse.player_uid;
                if (otherPlayer && !allowedToCrossOtherPlayers) {
                    continue;
                }
                const gScore = currentNode.g + (this.getDistanceBetweenStars(currentNode.star.uid, neighbor.star.uid) *
                    (otherPlayer ? otherPlayerWeightMultiplied : 1));
                let gScoreIsBest = false;
                if (!neighbor.visited) {
                    gScoreIsBest = true;
                    neighbor.h = Math.abs(parseFloat(endStar.x) - parseFloat(neighbor.star.x)) +
                        Math.abs(parseFloat(endStar.y) - parseFloat(neighbor.star.y));
                    neighbor.visited = true;
                    openList.push(neighbor);
                }
                else if (gScore < neighbor.g) {
                    gScoreIsBest = true;
                }
                if (gScoreIsBest) {
                    neighbor.parent = currentNode;
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                }
            }
        }
        return [];
    }
}
exports.TritonGame = TritonGame;
//# sourceMappingURL=game.js.map